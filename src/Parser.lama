-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun binOp(op) {
  [
    s(op),
    fun (l, _, r) {
      Binop(op, l, r)
    }
  ]
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
      exp = memo $ eta (expr (
        {
          [Left, binOp.map({"!!"})],
          [Left, binOp.map({"&&"})],
          [Nona, binOp.map({ "==", "!=", "<=", "<", ">=", ">"})],
          [Left, binOp.map({"+", "-"})],
          [Left, binOp.map({"/", "*", "%"})]
        },
        primary
      ));

var 
  primary_stmt = memo $ eta syntax (
    kRead var_name=inbr[s("("), lident, s(")")] { Read(var_name) }        |
    kWrite expr=inbr[s("("), exp, s(")")]       { Write(expr) }           |
    var_name=lident s[":="] expr=exp            { Assn(var_name, expr) }  |
    kSkip                                       { Skip }                  |
    stmt_if                                                               |
    stmt_loop
  ),
  stmt_loop = memo $ eta syntax (
    kFor ini=stmt s[","] cond=exp s[","] inc=stmt kDo 
      body=stmt 
    kOd  {
      Seq(
        ini,
        While(
          cond,
          Seq(body, inc)
        )
      )
    }
  | kWhile cond=exp kDo 
      body=stmt
    kOd { While(cond, body) }
  | kDo 
      body=stmt 
    kWhile cond=exp kOd { DoWhile(body, cond) }
  ),
  stmt_if = memo $ eta syntax (
    kIf cond=exp kThen 
      then_branch=stmt 
      else_branch=stmt_cond_else_part
    kFi {
      If(cond, then_branch, else_branch)
    }
  ),
  stmt_cond_else_part = memo $ eta syntax (
    empty { Skip }                                                            |
    kElse else_branch=stmt { else_branch }                                    |
    kElif cond=exp kThen then_branch=stmt else_branch=stmt_cond_else_part {
      If(cond, then_branch, else_branch)
    }
  ),
  stmt = memo $ eta syntax (
    primary_stmt |
    l=primary_stmt s[";"] r=stmt { Seq (l, r) }
  );
   

-- Public top-level parser
public parse = stmt;      
