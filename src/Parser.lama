-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;
import Ref;
import Collection;

-- Signals an error; takes an error message and location info
fun error (msg, loc) {
  failure ("%s at %d:%d\n", msg, loc.fst, loc.snd)
}

-- An attribute-processing functions
-- Attributes are:
--   Val  --- a plain value (aka "rvalue")
--   Ref  --- a reference to a mutable cell (aka "lvalue")
--   Void --- no value (aka "void"/"unit")

-- Checks if a plain value "val" can be used in the context described by
-- the attribute "atr".
fun assertValue (atr, v, loc) {
  case atr of
    Ref  -> error ("reference expected", loc)
  | Void -> Ignore (v)
  | _    -> v
  esac
}

fun assertVoid (atr, v, loc) {
  case atr of
    Void -> v
  | Val  -> error ("value expected", loc)
  | _    -> error ("reference expected", loc)
  esac
}

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun binop (op) {
  [syntax (pos -s[op]), fun (l, loc, r) {
                          fun (a) {
                            assertValue (a, Binop (op, l (Val), r (Val)), loc)
                          }
                        }
  ]
}

var primary  = memo $ eta syntax (
      -- decimal constant
      loc=pos x=decimal {
        fun (a) {
          assertValue (a, Const (stringInt (x)), loc)
        }
      } |
      -- identifier
      x=lident {
        fun (a) {
          case a of
            Ref  -> Ref (x)
          | Void -> Ignore (Var (x))
          | _    -> Var (x)
          esac
        }
      } |
      -- '(' exp ')'
      inbr[s("("), exp, s(")")] |
      -- read
      loc=pos kRead var_ref=inbr[s("("), exp, s(")")] {
        fun (a) {
          assertVoid (a, Read (var_ref (Ref)), loc)
        }
      } |
      -- write
      loc=pos kWrite expr=inbr[s("("), exp, s(")")] {
        fun (a) {
          assertVoid (a, Write (expr (Val)), loc)
        }
      } |
      -- skip
      loc=pos kSkip {
        fun (a) {
          assertVoid (a, Skip, loc)
        }
      } |
      -- if
      if_then_else |
      -- loop
      loop_exp
    ),
    loop_exp = memo $ eta syntax (
      loc=pos
      kFor ini=exp s[","] cond=exp s[","] inc=exp kDo 
        body=exp
      kOd {
        fun (a) {
          assertVoid (
            a,
            Seq (
              ini (Void),
              While (
                cond (Val),
                Seq (
                  body (Void),
                  inc (Void)
                )
              )
            ),
            loc
          )
        }
      } | 
      loc=pos 
      kWhile cond=exp kDo 
        body=exp
      kOd { 
        fun (a) {
          assertVoid (a, While (cond (Val), body (Void)), loc)
        }
      } |
      loc=pos
      kDo 
        body=exp 
      kWhile cond=exp kOd {
        fun (a) {
          assertVoid (a, DoWhile (body (Void), cond (Val)), loc)
        }
      }
    ),
    if_then_else = memo $ eta syntax (
      loc=pos
      kIf cond=exp kThen 
        then_branch=exp 
        else_branch=cond_else_part
      kFi {
        fun (a) {
          If(cond (Val), then_branch (a), else_branch (a))
        }
      }
    ),
    cond_else_part = memo $ eta syntax (
      loc=pos
      empty { 
        fun (a) {
          assertVoid (a, Skip, loc)
        }
      } |
      kElse else_branch=exp { else_branch }                                    |
      kElif cond=exp kThen then_branch=exp else_branch=cond_else_part {
        fun (a) {
          If(cond (Val), then_branch (a), else_branch (a))
        }
      }
    ),
    basic = memo $ eta (
      expr (
        {
          [Right, {[
              s (":="),
              fun (l, loc, r) {
                fun (a) {
                  assertValue (a, Assn (l (Ref), r (Val)), loc)
                }
              }
          ]}],
          [Left , map (binop, {"!!"})],
          [Left , map (binop, {"&&"})],
          [Nona , map (binop, {"==", "!=", "<", ">", "<=", ">="})],
          [Left , map (binop, {"+", "-"})],
          [Left , map (binop, {"*", "/", "%"})]
        },
        primary
      )
    ),
    exp      = memo $ eta syntax (
      basic | 
      s1=basic s[";"] s2=exp {
        fun (a) {
          Seq (s1 (Void), s2 (a))
        }
      }
    );

-- Public top-level parser
public parse = syntax (s=exp {s (Void)});
